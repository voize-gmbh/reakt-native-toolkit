package de.voize.reaktnativetoolkit.ksp.processor

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotation
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSTypeAlias
import com.google.devtools.ksp.symbol.KSTypeParameter
import com.google.devtools.ksp.symbol.KSTypeReference
import com.google.devtools.ksp.symbol.Origin
import io.outfoxx.typescriptpoet.CodeBlock
import io.outfoxx.typescriptpoet.CodeBlock.Companion.joinToCode
import io.outfoxx.typescriptpoet.EnumSpec
import io.outfoxx.typescriptpoet.FileSpec
import io.outfoxx.typescriptpoet.FunctionSpec
import io.outfoxx.typescriptpoet.InterfaceSpec
import io.outfoxx.typescriptpoet.Modifier
import io.outfoxx.typescriptpoet.ModuleSpec
import io.outfoxx.typescriptpoet.NameAllocator
import io.outfoxx.typescriptpoet.ParameterSpec
import io.outfoxx.typescriptpoet.PropertySpec
import io.outfoxx.typescriptpoet.TypeAliasSpec
import io.outfoxx.typescriptpoet.TypeName
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonClassDiscriminator
import java.io.OutputStreamWriter
import java.nio.charset.StandardCharsets
import java.util.UUID

private const val modelsModule = "models"

class TypescriptGenerator(
    private val resolver: Resolver,
    private val codeGenerator: CodeGenerator,
    private val options: Map<String, String>,
    private val logger: KSPLogger,
) {
    fun generate(rnModules: List<ToolkitSymbolProcessor.RNModule>) {
        // Collect all types of function parameters and return types
        val typeDeclarations =
            rnModules.flatMap { it.reactNativeMethods + it.reactNativeFlows }.flatMap {
                it.parameters.map { it.type } + (it.returnType ?: error("Type resolution error"))
            }.toSet().map { it.resolve() }

        val customTypes = filterTypesForGeneration(findAllUsedTypes(typeDeclarations))
        val rootNamespace = buildNamespaceTree("", customTypes)
        val originatingKSFiles = rnModules.mapNotNull { it.wrappedClassDeclaration.containingFile }

        // generate typescript models
        val typescriptModelsFileBuilder = FileSpec.builder(modelsModule)
        typescriptModelsFileBuilder.addComment("This file is generated by ReaktNativeToolkit. Do not edit.")
        val rootTypeDeclarationsModuleSpec =
            createTypescriptNamespaceWithTypeDeclarations(rootNamespace)
        rootTypeDeclarationsModuleSpec.members.forEach {
            when (it) {
                is InterfaceSpec -> {
                    typescriptModelsFileBuilder.addInterface(it)
                }

                is EnumSpec -> {
                    typescriptModelsFileBuilder.addEnum(it)
                }

                is TypeAliasSpec -> {
                    typescriptModelsFileBuilder.addTypeAlias(it)
                }

                is ModuleSpec -> {
                    typescriptModelsFileBuilder.addModule(it)
                }

                is FunctionSpec -> {
                    typescriptModelsFileBuilder.addFunction(it)
                }


                else -> error("Unsupported member ${it::class.simpleName}")
            }
        }
        val typescriptModelsFile = typescriptModelsFileBuilder.build()
        typescriptModelsFile.writeTo(codeGenerator, kspDependencies(true, originatingKSFiles))

        // generate typescript rn modules
        val rnModulesFileBuilder = FileSpec.builder("modules")
        rnModulesFileBuilder.addComment("This file is generated by ReaktNativeToolkit. Do not edit.")
        rnModules.forEach {
            createTypescriptRNModule(it, rnModulesFileBuilder)
        }
        // TODO workaround for not working import
        rnModulesFileBuilder.addTypeAlias(
            TypeAliasSpec.builder(
                "_workaround",
                TypeName.namedImport("NativeEventEmitter", "react-native"),
            ).build()
        )
        val rnModulesFile = rnModulesFileBuilder.build()
        rnModulesFile.writeTo(codeGenerator, kspDependencies(true, originatingKSFiles))
    }

    private fun createTypescriptRNModule(
        rnModule: ToolkitSymbolProcessor.RNModule,
        fileBuilder: FileSpec.Builder
    ) {
        val nativeModulesType = TypeName.namedImport("NativeModules", "react-native")

        val withEventEmitter = rnModule.supportedEvents.isNotEmpty()

        val nativeInterfaceName = "Native" + rnModule.moduleName + "Interface"
        val nativeRNModuleInterface = InterfaceSpec.builder(nativeInterfaceName).apply {
            addFunctions(
                rnModule.reactNativeMethods.map { functionDeclaration ->
                    val parameters = functionDeclaration.parameters.map {
                        ParameterSpec.builder(
                            it.name?.asString() ?: error("Parameter must have a name"),
                            getTypescriptSerializedTypeName(it.type.resolve())
                        ).build()
                    }

                    FunctionSpec.builder(functionDeclaration.simpleName.asString())
                        .addModifiers(Modifier.ABSTRACT)
                        .addParameters(parameters)
                        .returns(TypeName.PROMISE.parameterized(functionDeclaration.returnType?.resolve()
                            ?.let { getTypescriptSerializedTypeName(it) } ?: TypeName.VOID))
                        .build()
                }
            )
            addProperties(
                rnModule.reactNativeFlows.map { functionDeclaration ->
                    reactNativeFlowToNextProperty(functionDeclaration, true)
                }
            )
        }.build()

        val interfaceName = rnModule.moduleName + "Interface"
        val rnModuleInterface = InterfaceSpec.builder(interfaceName).apply {
            addModifiers(Modifier.EXPORT)
            addTSDoc(
                "Module generated from {@link %N}.\n",
                rnModule.wrappedClassDeclaration.qualifiedName!!.asString()
            )
            addFunctions(
                rnModule.reactNativeMethods.map { functionDeclaration ->
                    val parameters = functionDeclaration.parameters.map {
                        ParameterSpec.builder(
                            it.name?.asString() ?: error("Parameter must have a name"),
                            getTypescriptTypeName(it.type.resolve())
                        )
                            .build()
                    }

                    FunctionSpec.builder(functionDeclaration.simpleName.asString())
                        .addModifiers(Modifier.ABSTRACT)
                        .addParameters(parameters)
                        .returns(TypeName.PROMISE.parameterized(functionDeclaration.returnType?.resolve()
                            ?.let { getTypescriptTypeName(it) } ?: TypeName.VOID))
                        .build()
                }
            )
            if (withEventEmitter) {
                addFunction(
                    FunctionSpec.builder("addEventListener")
                        .addModifiers(Modifier.ABSTRACT)
                        .addParameter(
                            ParameterSpec.builder(
                                "key",
                                TypeName.STRING,
                            ).build()
                        )
                        .addParameter(
                            ParameterSpec.builder(
                                "listener",
                                TypeName.lambda(
                                    "result" to TypeName.ANY,
                                    returnType = TypeName.VOID,
                                ),
                            ).build()
                        )
                        .returns(TypeName.namedImport("EmitterSubscription", "react-native"))
                        .build()
                )
            }
            addProperties(
                rnModule.reactNativeFlows.map { functionDeclaration ->
                    reactNativeFlowToNextProperty(functionDeclaration, false)
                }
            )
        }.build()

        fileBuilder.addType(nativeRNModuleInterface)
        fileBuilder.addType(rnModuleInterface)
        val nativeRNModule = "Native" + rnModule.moduleName
        val nameAllocator = NameAllocator()
        nameAllocator.newName(nativeRNModule)
        fileBuilder.addCode(
            CodeBlock.of(
                "const %N = %T.%N as %T",
                nativeRNModule,
                nativeModulesType,
                rnModule.moduleName,
                TypeName.implicit(nativeInterfaceName)
            )
        )
        nameAllocator.newName(rnModule.moduleName)
        fileBuilder.addCode(
            CodeBlock.of(
                """
            export const %N: %T = {
            %>...%N,
            %L%<
            }
            """.trimIndent(),
                rnModule.moduleName,
                TypeName.implicit(interfaceName),
                nativeRNModule,
                buildList {
                    fun KSFunctionDeclaration.toParametersAndPassedValues(nameAllocator: NameAllocator): Pair<List<CodeBlock>, List<CodeBlock>> {
                        val parameterTags = parameters.map {
                            val tag = UUID.randomUUID()
                            nameAllocator.newName(
                                it.name?.asString() ?: error("Parameter must have a name"), tag
                            )
                            tag
                        }
                        return Pair(
                            parameters.zip(parameterTags).map { (parameter, tag) ->
                                CodeBlock.of(
                                    "%N: %T",
                                    nameAllocator[tag],
                                    getTypescriptTypeName(parameter.type.resolve()),
                                )
                            },
                            parameters.zip(parameterTags).map { (parameter, tag) ->
                                val name = nameAllocator[tag]
                                val type = parameter.type.resolve()
                                val value = convertTypeToJson(
                                    CodeBlock.of("%N", name),
                                    type,
                                    nameAllocator.copy()
                                )
                                if (needsSerialization(type)) {
                                    CodeBlock.of(
                                        "%T.%N(%L)",
                                        TypescriptJsonTypeName,
                                        "stringify",
                                        value,
                                    )
                                } else {
                                    value
                                }

                            })
                    }

                    addAll((rnModule.reactNativeMethods).map { functionDeclaration ->
                        val functionNameAllocator = nameAllocator.copy()
                        val (parameters, parameterSerialization) = functionDeclaration.toParametersAndPassedValues(
                            functionNameAllocator
                        )

                        val returnType =
                            functionDeclaration.returnType?.resolve() ?: resolver.builtIns.unitType

                        val returnValueDeserialization =
                            if (needsSerialization(returnType)) {
                                CodeBlock.of(
                                    ".%N(%T.%N)",
                                    "then",
                                    TypescriptJsonTypeName,
                                    "parse",
                                )
                            } else {
                                CodeBlock.empty()
                            }

                        val returnNameAllocator = functionNameAllocator.copy()
                        val resultTag = UUID.randomUUID()
                        returnNameAllocator.newName("result", resultTag)
                        val returnValueMapping =
                            CodeBlock.of(
                                ".%N((%N) =>%W%L)",
                                "then",
                                returnNameAllocator[resultTag],
                                convertJsonToType(
                                    CodeBlock.of(returnNameAllocator[resultTag]),
                                    returnType,
                                    returnNameAllocator.copy(),
                                )
                            )

                        // wrap native function into arrow to prevent passing to too many arguments from resulting in an error
                        CodeBlock.of(
                            "%N: (%L) =>%W%N.%N(%L)%L%L",
                            functionDeclaration.simpleName.asString(),
                            parameters.joinToCode(),
                            nativeRNModule,
                            functionDeclaration.simpleName.asString(),
                            parameterSerialization.joinToCode(),
                            returnValueDeserialization,
                            returnValueMapping,
                        )
                    })
                    addAll((rnModule.reactNativeFlows).map { functionDeclaration ->
                        val functionNameAllocator = nameAllocator.copy()
                        val currentValueTag = UUID.randomUUID()
                        functionNameAllocator.newName("currentValue", currentValueTag)

                        val currentValueParameter = CodeBlock.of(
                            "%N: %T",
                            functionNameAllocator[currentValueTag],
                            TypeName.STRING.asNullable(),
                        )

                        val currentValuePassedParameter =
                            CodeBlock.of("%N", functionNameAllocator[currentValueTag])

                        val (parameters, parameterSerialization) = functionDeclaration.toParametersAndPassedValues(
                            functionNameAllocator
                        )

                        CodeBlock.of(
                            "%N: (%L) =>%W%N.%N(%L)",
                            functionDeclaration.simpleName.asString(),
                            (listOf(currentValueParameter) + parameters).joinToCode(),
                            nativeRNModule,
                            functionDeclaration.simpleName.asString(),
                            (listOf(currentValuePassedParameter) + parameterSerialization).joinToCode(),
                        )
                    })
                    if (withEventEmitter) {
                        val eventEmitterVarName = "eventEmitter"
                        val keyVarName = "key"
                        val listenerVarName = "listener"

                        val parameters = listOf(
                            CodeBlock.of(
                                "%N: %T",
                                keyVarName,
                                TypeName.STRING,
                            ),
                            CodeBlock.of(
                                "%N: %T",
                                listenerVarName,
                                TypeName.lambda(
                                    "result" to TypeName.ANY,
                                    returnType = TypeName.VOID,
                                ),
                            )
                        ).joinToCode()
                        add(
                            CodeBlock.of(
                                "%N: (%L) => {\n%>%L%<}",
                                "addEventListener",
                                parameters,
                                CodeBlock.builder().apply {
                                    addStatement(
                                        "const %N = new %T(%N as %T)",
                                        eventEmitterVarName,
                                        TypeName.namedImport("NativeEventEmitter", "react-native"),
                                        nativeRNModule,
                                        TypeName.ANY,
                                    )
                                    // TODO deserialize result
                                    addStatement(
                                        "return %N.addListener(%N, %N)",
                                        eventEmitterVarName,
                                        keyVarName,
                                        listenerVarName,
                                    )
                                }.build()
                            )
                        )
                    }
                }.joinToCode(",\n")
            )
        )
    }

    private fun reactNativeFlowToNextProperty(
        functionDeclaration: KSFunctionDeclaration,
        useSerializedParameterTypes: Boolean,
    ): PropertySpec {
        val returnTypeName = getTypescriptTypeName(
            (functionDeclaration.returnType!!.resolve().arguments.single().type
                ?: error("Flow Type can not use star projection")).resolve()
        )
        val parameters = functionDeclaration.parameters.map {
            if (useSerializedParameterTypes) {
                getTypescriptSerializedTypeName(it.type.resolve())
            } else {
                getTypescriptTypeName(it.type.resolve())
            }
        }

        val nextTypeName = when (parameters.size) {
            0 -> NextTypeName.parameterized(returnTypeName)
            1 -> Next1TypeName.parameterized(returnTypeName, parameters[0])
            2 -> Next2TypeName.parameterized(returnTypeName, parameters[0], parameters[1])
            else -> NextXTypeName.parameterized(returnTypeName)
        }

        return PropertySpec.builder(functionDeclaration.simpleName.asString(), nextTypeName)
            .build()
    }

    /**
     * Construct the typescript name for a given declaration.
     * Nested declarations are concatenated with the parent declaration name.
     */
    private fun KSDeclaration.getTypescriptName(): String {
        return simpleName.asString()
    }

    private fun KSDeclaration.getTypescriptNameWithNamespace(): String {
        return "${getTypescriptNamespace()}.${getTypescriptName()}".removePrefix(".")
    }

    private fun KSDeclaration.getTypescriptNamespace(): String {
        val parent = parentDeclaration
        return if (parent != null) {
            "${parent.getTypescriptNamespace()}.${parent.getTypescriptName()}".removePrefix(".")
        } else {
            packageName.asString()
        }
    }

    private fun KSDeclaration.getTypescriptToJsonFunctionName(): String {
        return "toJson${getTypescriptName()}"
    }

    private fun KSDeclaration.getTypescriptToJsonFunctionNameWithNamespace(): String {
        return "${getTypescriptNamespace()}.${getTypescriptToJsonFunctionName()}".removePrefix(".")
    }

    private fun KSDeclaration.getTypescriptFromJsonFunctionName(): String {
        return "fromJson${getTypescriptName()}"
    }

    private fun KSDeclaration.getTypescriptFromJsonFunctionNameWithNamespace(): String {
        return "${getTypescriptNamespace()}.${getTypescriptFromJsonFunctionName()}".removePrefix(".")
    }

    private fun getTypescriptTypeNameForDateTime(
        ksType: KSType,
        annotations: Sequence<KSAnnotation>?
    ): TypeName {
        val jsTypeAnnotation = (annotations ?: ksType.annotations).getJSTypeAnnotationOrNull()
        val jsTypeIdentifier = jsTypeAnnotation?.getJSTypeIdentifier()
        return when (ksType.declaration.qualifiedName?.asString()) {
            "kotlin.time.Duration" -> TypeName.STRING
            "kotlinx.datetime.Instant" -> when (val identifier =
                jsTypeIdentifier ?: getDefaultInstantJSType()) {
                "string" -> TypeName.STRING
                "date" -> TypeName.DATE
                else -> error("Unsupported JSType identifier for Instant: $identifier")
            }

            "kotlinx.datetime.LocalDate" -> TypeName.STRING
            "kotlinx.datetime.LocalDateTime" -> TypeName.STRING
            "kotlinx.datetime.LocalTime" -> TypeName.STRING
            else -> error("Unsupported declaration for date time: ${ksType.declaration}")
        }
    }

    private fun getTypescriptTypeName(
        ksType: KSType,
        annotations: Sequence<KSAnnotation>? = null
    ): TypeName {
        if (ksType.isError) {
            return TypeName.ANY
        }

        val module = "!$modelsModule"
        fun resolveTypeArgument(index: Int): TypeName {
            val argument = ksType.arguments[index]
            val type = argument.type
            if (type != null) {
                return getTypescriptTypeName(type.resolve(), argument.annotations)
            } else {
                error("Could not resolve type argument")
            }
        }

        val typeName = when (ksType.declaration.qualifiedName?.asString()) {
            "kotlin.Any" -> TypeName.ANY
            "kotlin.Boolean" -> TypeName.BOOLEAN
            "kotlin.Byte" -> TypeName.NUMBER
            "kotlin.Char" -> TypeName.NUMBER
            "kotlin.Double" -> TypeName.NUMBER
            "kotlin.Float" -> TypeName.NUMBER
            "kotlin.Int" -> TypeName.NUMBER
            "kotlin.Long" -> TypeName.NUMBER
            "kotlin.Number" -> TypeName.NUMBER
            "kotlin.Short" -> TypeName.NUMBER
            "kotlin.String" -> TypeName.STRING
            "kotlin.Unit" -> TypeName.VOID
            else -> null
        } ?: when (ksType.declaration.qualifiedName?.asString()) {
            "kotlin.Array", "kotlin.collections.List", "kotlin.collections.Set" -> TypeName.arrayType(
                resolveTypeArgument(0)
            )

            "kotlin.collections.Map" -> recordType(
                resolveTypeArgument(0),
                resolveTypeArgument(1),
            )

            else -> null
        } ?: when (ksType.declaration.qualifiedName?.asString()) {
            "kotlin.time.Duration",
            "kotlinx.datetime.Instant",
            "kotlinx.datetime.LocalDate",
            "kotlinx.datetime.LocalDateTime",
            "kotlinx.datetime.LocalTime" -> getTypescriptTypeNameForDateTime(ksType, annotations)

            else -> {
                val declaration = ksType.declaration
                if (declaration.origin != Origin.KOTLIN) {
                    // TODO support external classes
                    logger.warn("External declarations are not supported and are stubbed with any: ${declaration.qualifiedName?.asString()}")
                    TypeName.ANY
                } else when (declaration) {
                    is KSClassDeclaration -> when (declaration.classKind) {
                        ClassKind.INTERFACE -> error("Interfaces are not supported")
                        ClassKind.CLASS -> {
                            if (com.google.devtools.ksp.symbol.Modifier.DATA in declaration.modifiers) {
                                // data class
                                TypeName.namedImport(
                                    declaration.getTypescriptNameWithNamespace(),
                                    module
                                )
                            } else if (com.google.devtools.ksp.symbol.Modifier.SEALED in declaration.modifiers) {
                                TypeName.namedImport(
                                    declaration.getTypescriptNameWithNamespace(),
                                    module
                                )
                            } else {
                                error("Only data classes and sealed classes are supported, found: $declaration")
                            }
                        }

                        ClassKind.ENUM_CLASS -> {
                            TypeName.namedImport(
                                declaration.getTypescriptNameWithNamespace(),
                                module
                            )
                        }

                        ClassKind.ENUM_ENTRY -> error("Enum entries are not supported")
                        ClassKind.OBJECT -> TypeName.namedImport(
                            declaration.getTypescriptNameWithNamespace(),
                            module
                        )

                        ClassKind.ANNOTATION_CLASS -> error("Annotation classes are not supported")
                    }

                    is KSFunctionDeclaration -> {
                        error("Function declarations are not supported")
                    }

                    is KSTypeAlias -> {
                        // TODO support type aliases
                        TypeName.namedImport(declaration.getTypescriptNameWithNamespace(), module)
                    }

                    is KSPropertyDeclaration -> {
                        error("Property declarations are not supported")
                    }

                    is KSTypeParameter -> {
                        // TODO handle bounds
                        TypeName.typeVariable(declaration.name.asString())
                    }

                    else -> {
                        error("Unsupported declaration: $declaration")
                    }
                }
            }
        }

        return typeName.withNullable(ksType.isMarkedNullable)
    }

    private fun getTypescriptSerializedTypeName(ksType: KSType): TypeName {
        val useJsonSerialization = true
        if (ksType.isError) {
            return TypeName.ANY
        }

        fun resolveTypeArgument(index: Int): TypeName {
            val argument = ksType.arguments[index]
            val type = argument.type
            if (type != null) {
                return getTypescriptSerializedTypeName(type.resolve())
            } else {
                error("Could not resolve type argument")
            }
        }

        return when (ksType.declaration.qualifiedName?.asString()) {
            "kotlin.Any" -> TypeName.ANY
            "kotlin.Boolean" -> TypeName.BOOLEAN
            "kotlin.Byte" -> TypeName.NUMBER
            "kotlin.Char" -> TypeName.NUMBER
            "kotlin.Double" -> TypeName.NUMBER
            "kotlin.Float" -> TypeName.NUMBER
            "kotlin.Int" -> TypeName.NUMBER
            "kotlin.Long" -> TypeName.NUMBER
            "kotlin.Number" -> TypeName.NUMBER
            "kotlin.Short" -> TypeName.NUMBER
            "kotlin.String" -> TypeName.STRING
            "kotlin.Unit" -> TypeName.VOID
            else -> null
        }?.withNullable(ksType.isMarkedNullable)
            ?: if (useJsonSerialization) {
                when (ksType.declaration.qualifiedName?.asString()) {
                    "kotlin.Array", "kotlin.collections.List", "kotlin.collections.Set" -> TypeName.STRING
                    "kotlin.collections.Map" -> TypeName.STRING
                    else -> null
                }
            } else {
                when (ksType.declaration.qualifiedName?.asString()) {
                    "kotlin.Array", "kotlin.collections.List", "kotlin.collections.Set" -> TypeName.arrayType(
                        resolveTypeArgument(0)
                    )

                    "kotlin.collections.Map" -> recordType(
                        resolveTypeArgument(0),
                        resolveTypeArgument(1),
                    )

                    else -> null
                }?.withNullable(ksType.isMarkedNullable)
            }
            ?: when (ksType.declaration.qualifiedName?.asString()) {
                "kotlin.time.Duration" -> TypeName.STRING
                "kotlinx.datetime.Instant" -> TypeName.STRING
                "kotlinx.datetime.LocalDate" -> TypeName.STRING
                "kotlinx.datetime.LocalDateTime" -> TypeName.STRING
                "kotlinx.datetime.LocalTime" -> TypeName.STRING
                else -> when (val declaration = ksType.declaration) {
                    is KSClassDeclaration -> {
                        when (declaration.classKind) {
                            ClassKind.INTERFACE -> error("Interfaces are not supported")
                            ClassKind.CLASS -> {
                                if (com.google.devtools.ksp.symbol.Modifier.DATA in declaration.modifiers) {
                                    // data class
                                    TypeName.STRING
                                } else if (com.google.devtools.ksp.symbol.Modifier.SEALED in declaration.modifiers) {
                                    // sealed class
                                    TypeName.STRING
                                } else {
                                    error("Only data classes and sealed classes are supported")
                                }
                            }

                            ClassKind.ENUM_CLASS -> TypeName.STRING
                            ClassKind.ENUM_ENTRY -> error("Enum entries are not supported")
                            ClassKind.OBJECT -> TypeName.STRING
                            ClassKind.ANNOTATION_CLASS -> error("Annotation classes are not supported")
                        }
                    }

                    is KSFunctionDeclaration -> {
                        error("Function declarations are not supported")
                    }

                    is KSTypeAlias -> {
                        getTypescriptSerializedTypeName(declaration.type.resolve())
                    }

                    is KSPropertyDeclaration -> {
                        error("Property declarations are not supported")
                    }

                    is KSTypeParameter -> {
                        // TODO handle bounds
                        TypeName.typeVariable(declaration.name.asString())
                    }

                    else -> {
                        error("Unsupported declaration: $declaration")
                    }
                }
            }
    }

    private fun convertJsonToType(
        json: CodeBlock,
        ksType: KSType,
        nameAllocator: NameAllocator,
        annotations: Sequence<KSAnnotation>? = null
    ): CodeBlock {
        if (ksType.isError) {
            return json
        }

        val jsTypeAnnotation = (annotations ?: ksType.annotations).getJSTypeAnnotationOrNull()
        val jsTypeIdentifier = jsTypeAnnotation?.getJSTypeIdentifier()

        return json.ifNotNull(
            ksType.isMarkedNullable,
            nameAllocator
        ) { nonNullVariableName, nameAllocator ->
            fun convertTypeArgument(
                argumentValue: CodeBlock,
                index: Int
            ): CodeBlock {
                val argument = ksType.arguments[index]
                val type = argument.type
                if (type != null) {
                    return convertJsonToType(
                        argumentValue,
                        type.resolve(),
                        nameAllocator.copy(),
                        argument.annotations
                    )
                } else {
                    error("Could not convert type argument")
                }
            }

            when (ksType.declaration.qualifiedName?.asString()) {
                "kotlin.Any" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Boolean" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Byte" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Char" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Double" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Float" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Int" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Long" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Number" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Short" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.String" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Unit" -> CodeBlock.of("%N", nonNullVariableName)
                else -> null
            } ?: when (ksType.declaration.qualifiedName?.asString()) {
                "kotlin.Array",
                "kotlin.collections.List",
                "kotlin.collections.Set" -> {
                    val arrayItemTag = UUID.randomUUID()
                    nameAllocator.newName("it", arrayItemTag)
                    CodeBlock.of(
                        "%N.map((%N: %T) => %L)",
                        nonNullVariableName,
                        nameAllocator[arrayItemTag],
                        TypeName.ANY,
                        convertTypeArgument(CodeBlock.of("%N", nameAllocator[arrayItemTag]), 0)
                    )
                }

                "kotlin.collections.Map" -> {
                    val mapItemKeyTag = UUID.randomUUID()
                    val mapItemValueTag = UUID.randomUUID()
                    nameAllocator.newName("key", mapItemKeyTag)
                    nameAllocator.newName("value", mapItemValueTag)
                    CodeBlock.of(
                        "%T.%N(%T.%N(%N).map(([%N, %N]: [%T, %T]) => [%L, %L]))",
                        TypescriptObjectTypeName,
                        "fromEntries",
                        TypescriptObjectTypeName,
                        "entries",
                        nonNullVariableName,
                        nameAllocator[mapItemKeyTag],
                        nameAllocator[mapItemValueTag],
                        TypeName.ANY,
                        TypeName.ANY,
                        convertTypeArgument(CodeBlock.of("%N", nameAllocator[mapItemKeyTag]), 0),
                        convertTypeArgument(CodeBlock.of("%N", nameAllocator[mapItemValueTag]), 1),
                    )
                }

                else -> null
            } ?: when (ksType.declaration.qualifiedName?.asString()) {
                "kotlin.time.Duration" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlinx.datetime.Instant" -> when (val identifier =
                    jsTypeIdentifier ?: getDefaultInstantJSType()) {
                    "string" -> CodeBlock.of("%N", nonNullVariableName)
                    "date" -> CodeBlock.of(
                        "new %T(%N)",
                        TypescriptDateTypeName,
                        nonNullVariableName,
                    )

                    else -> error("Unsupported JSType identifier for Instant: $identifier")
                }

                "kotlinx.datetime.LocalDate" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlinx.datetime.LocalDateTime" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlinx.datetime.LocalTime" -> CodeBlock.of("%N", nonNullVariableName)

                else -> {
                    val declaration = ksType.declaration
                    if (declaration.origin != Origin.KOTLIN) {
                        // TODO support external classes
                        logger.warn("External declarations are not supported and are not mapped: ${declaration.qualifiedName?.asString()}")
                        CodeBlock.of("%N", nonNullVariableName)
                    } else when (declaration) {
                        is KSClassDeclaration -> when (declaration.classKind) {
                            ClassKind.INTERFACE -> error("Interfaces are not supported")
                            ClassKind.CLASS -> {
                                if (com.google.devtools.ksp.symbol.Modifier.DATA in declaration.modifiers) {
                                    // data class
                                    CodeBlock.of(
                                        "%N(%N)",
                                        declaration.getTypescriptFromJsonFunctionNameWithNamespace(),
                                        nonNullVariableName,
                                    )
                                } else if (com.google.devtools.ksp.symbol.Modifier.SEALED in declaration.modifiers) {
                                    // sealed class
                                    CodeBlock.of(
                                        "%N(%N)",
                                        declaration.getTypescriptFromJsonFunctionNameWithNamespace(),
                                        nonNullVariableName,
                                    )
                                } else {
                                    error("Only data classes and sealed classes are supported, found: $declaration")
                                }
                            }

                            ClassKind.ENUM_CLASS -> {
                                CodeBlock.of(
                                    "%N(%N)",
                                    declaration.getTypescriptFromJsonFunctionNameWithNamespace(),
                                    nonNullVariableName,
                                )
                            }

                            ClassKind.ENUM_ENTRY -> error("Enum entries are not supported")
                            ClassKind.OBJECT -> CodeBlock.of(
                                "%N(%N)",
                                declaration.getTypescriptFromJsonFunctionNameWithNamespace(),
                                nonNullVariableName,
                            )

                            ClassKind.ANNOTATION_CLASS -> error("Annotation classes are not supported")
                        }

                        is KSFunctionDeclaration -> {
                            error("Function declarations are not supported")
                        }

                        is KSTypeAlias -> {
                            // TODO support type aliases
                            CodeBlock.of("%N", nonNullVariableName)
                        }

                        is KSPropertyDeclaration -> {
                            error("Property declarations are not supported")
                        }

                        is KSTypeParameter -> {
                            // TODO handle bounds
                            CodeBlock.of("%N", nonNullVariableName)
                        }

                        else -> {
                            error("Unsupported declaration: $declaration")
                        }
                    }
                }
            }
        }

    }

    private fun convertTypeToJson(
        value: CodeBlock,
        ksType: KSType,
        nameAllocator: NameAllocator,
        annotations: Sequence<KSAnnotation>? = null
    ): CodeBlock {
        if (ksType.isError) {
            return value
        }

        val jsTypeAnnotation = (annotations ?: ksType.annotations).getJSTypeAnnotationOrNull()
        val jsTypeIdentifier = jsTypeAnnotation?.getJSTypeIdentifier()

        return value.ifNotNull(
            ksType.isMarkedNullable,
            nameAllocator
        ) { nonNullVariableName, nameAllocator ->
            fun convertTypeArgument(
                argumentValue: CodeBlock,
                index: Int
            ): CodeBlock {
                val argument = ksType.arguments[index]
                val type = argument.type
                if (type != null) {
                    return convertTypeToJson(
                        argumentValue,
                        type.resolve(),
                        nameAllocator.copy(),
                        argument.annotations
                    )
                } else {
                    error("Could not convert type argument")
                }
            }

            when (ksType.declaration.qualifiedName?.asString()) {
                "kotlin.Any" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Boolean" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Byte" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Char" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Double" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Float" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Int" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Long" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Number" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Short" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.String" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlin.Unit" -> CodeBlock.of("%N", nonNullVariableName)
                else -> null
            } ?: when (ksType.declaration.qualifiedName?.asString()) {
                "kotlin.Array",
                "kotlin.collections.List",
                "kotlin.collections.Set" -> {
                    val arrayItemTag = UUID.randomUUID()
                    nameAllocator.newName("it", arrayItemTag)
                    CodeBlock.of(
                        "%N.map((%N: %T) => %L)",
                        nonNullVariableName,
                        nameAllocator[arrayItemTag],
                        TypeName.ANY,
                        convertTypeArgument(CodeBlock.of("%N", nameAllocator[arrayItemTag]), 0)
                    )
                }

                "kotlin.collections.Map" -> {
                    val mapItemKeyTag = UUID.randomUUID()
                    val mapItemValueTag = UUID.randomUUID()
                    nameAllocator.newName("key", mapItemKeyTag)
                    nameAllocator.newName("value", mapItemValueTag)
                    CodeBlock.of(
                        "%T.%N(%T.%N(%N).map(([%N, %N]: [%T, %T]) => [%L, %L]))",
                        TypescriptObjectTypeName,
                        "fromEntries",
                        TypescriptObjectTypeName,
                        "entries",
                        nonNullVariableName,
                        nameAllocator[mapItemKeyTag],
                        nameAllocator[mapItemValueTag],
                        TypeName.ANY,
                        TypeName.ANY,
                        convertTypeArgument(CodeBlock.of("%N", nameAllocator[mapItemKeyTag]), 0),
                        convertTypeArgument(CodeBlock.of("%N", nameAllocator[mapItemValueTag]), 1),
                    )
                }

                else -> null
            } ?: when (ksType.declaration.qualifiedName?.asString()) {
                "kotlin.time.Duration" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlinx.datetime.Instant" -> when (val identifier =
                    jsTypeIdentifier ?: getDefaultInstantJSType()) {
                    "string" -> CodeBlock.of("%N", nonNullVariableName)
                    "date" -> CodeBlock.of(
                        "%N.%N()",
                        nonNullVariableName,
                        "toISOString",
                    )

                    else -> error("Unsupported JSType identifier for Instant: $identifier")
                }

                "kotlinx.datetime.LocalDate" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlinx.datetime.LocalDateTime" -> CodeBlock.of("%N", nonNullVariableName)
                "kotlinx.datetime.LocalTime" -> CodeBlock.of("%N", nonNullVariableName)

                else -> {
                    val declaration = ksType.declaration
                    if (declaration.origin != Origin.KOTLIN) {
                        // TODO support external classes
                        logger.warn("External declarations are not supported and are not mapped: ${declaration.qualifiedName?.asString()}")
                        CodeBlock.of("%N", nonNullVariableName)
                    } else when (declaration) {
                        is KSClassDeclaration -> when (declaration.classKind) {
                            ClassKind.INTERFACE -> error("Interfaces are not supported")
                            ClassKind.CLASS -> {
                                if (com.google.devtools.ksp.symbol.Modifier.DATA in declaration.modifiers) {
                                    // data class
                                    CodeBlock.of(
                                        "%N(%N)",
                                        declaration.getTypescriptToJsonFunctionNameWithNamespace(),
                                        nonNullVariableName,
                                    )
                                } else if (com.google.devtools.ksp.symbol.Modifier.SEALED in declaration.modifiers) {
                                    // sealed class
                                    CodeBlock.of(
                                        "%N(%N)",
                                        declaration.getTypescriptToJsonFunctionNameWithNamespace(),
                                        nonNullVariableName,
                                    )
                                } else {
                                    error("Only data classes and sealed classes are supported, found: $declaration")
                                }
                            }

                            ClassKind.ENUM_CLASS -> {
                                CodeBlock.of(
                                    "%N(%N)",
                                    declaration.getTypescriptToJsonFunctionNameWithNamespace(),
                                    nonNullVariableName,
                                )
                            }

                            ClassKind.ENUM_ENTRY -> error("Enum entries are not supported")
                            ClassKind.OBJECT -> CodeBlock.of(
                                "%N(%N)",
                                declaration.getTypescriptToJsonFunctionNameWithNamespace(),
                                nonNullVariableName
                            )

                            ClassKind.ANNOTATION_CLASS -> error("Annotation classes are not supported")
                        }

                        is KSFunctionDeclaration -> {
                            error("Function declarations are not supported")
                        }

                        is KSTypeAlias -> {
                            // TODO support type aliases
                            CodeBlock.of("%N", nonNullVariableName)
                        }

                        is KSPropertyDeclaration -> {
                            error("Property declarations are not supported")
                        }

                        is KSTypeParameter -> {
                            // TODO handle bounds
                            CodeBlock.of("%N", nonNullVariableName)
                        }

                        else -> {
                            error("Unsupported declaration: $declaration")
                        }
                    }
                }
            }
        }
    }


    @OptIn(KspExperimental::class)
    private fun KSDeclaration.getSerialNameAnnotationOrNull(): SerialName? =
        getAnnotationsByType(SerialName::class).singleOrNull()

    @OptIn(KspExperimental::class)
    private fun KSDeclaration.assertSerializable(message: () -> String) =
        getAnnotationsByType(Serializable::class).singleOrNull() ?: error(message)

    @OptIn(KspExperimental::class, ExperimentalSerializationApi::class)
    private fun KSDeclaration.getJsonClassDiscriminatorAnnotationOrNull(): JsonClassDiscriminator? =
        getAnnotationsByType(JsonClassDiscriminator::class).singleOrNull()

    private fun Sequence<KSAnnotation>.getJSTypeAnnotationOrNull(): KSAnnotation? =
        singleOrNull {
            it.shortName.getShortName() == "JSType" &&
                    it.annotationType.resolve().declaration.qualifiedName?.asString() == "de.voize.reaktnativetoolkit.annotation.JSType"
        }

    private fun KSAnnotation.getJSTypeIdentifier(): String {
        return arguments.single {
            it.name?.asString() == "identifier"
        }.value as String
    }

    private fun createTypescriptNamespaceWithTypeDeclarations(namespace: NamespaceNode): ModuleSpec {
        return ModuleSpec.builder(namespace.name)
            .apply {
                addModifier(Modifier.EXPORT)
                namespace.declarations.forEach { declaration ->
                    createTypescriptTypeDeclaration(declaration, this)
                    createTypescriptTypeMapping(declaration, this)
                }
                namespace.children.map(::createTypescriptNamespaceWithTypeDeclarations).forEach {
                    addModule(it)
                }
            }.build()
    }

    private fun createTypescriptTypeDeclaration(
        declaration: KSDeclaration,
        typescriptFileBuilder: ModuleSpec.Builder,
    ) {
        when (declaration.qualifiedName) {
            else -> when (declaration) {
                is KSClassDeclaration -> {
                    val sealedBaseType = declaration.getSealedTypescriptBaseType()

                    when (declaration.classKind) {
                        ClassKind.INTERFACE -> error("Interfaces are not supported")
                        ClassKind.CLASS -> {
                            if (com.google.devtools.ksp.symbol.Modifier.DATA in declaration.modifiers) {
                                // data class
                                declaration.assertSerializable {
                                    "Data classes must be annotated with @Serializable: $declaration"
                                }
                                val interfaceSpec =
                                    InterfaceSpec.builder(declaration.getTypescriptName()).apply {
                                        addModifiers(Modifier.EXPORT)
                                        if (sealedBaseType != null) {
                                            addSuperInterface(sealedBaseType)
                                        }
                                        addTSDoc(
                                            "Data class generated from {@link %N}\n",
                                            declaration.qualifiedName!!.asString()
                                        )
                                        addProperties(
                                            declaration.getAllProperties()
                                                .map { toTypescriptPropertySpec(it) }.toList()
                                        )
                                    }.build()
                                typescriptFileBuilder.addInterface(interfaceSpec)
                            } else if (com.google.devtools.ksp.symbol.Modifier.SEALED in declaration.modifiers) {
                                if (sealedBaseType != null) {
                                    error("Sealed classes as direct members of other sealed classes are not supported: $declaration")
                                }
                                declaration.assertSerializable {
                                    "Sealed classes must be annotated with @Serializable: $declaration"
                                }
                                val subclasses = declaration.getSealedSubclasses()
                                val subclassesToDiscriminator =
                                    subclasses.associateWith { it.getSealedSubclassDiscriminatorValue() }
                                val typeEnumName = declaration.getTypescriptName() + "Type"
                                val typeEnumTypeName = TypeName.implicit(typeEnumName)
                                EnumSpec.builder(typeEnumName).apply {
                                    addModifiers(Modifier.EXPORT)
                                    subclassesToDiscriminator.forEach { (subclassDeclaration, discriminator) ->
                                        addConstant(
                                            subclassDeclaration.getTypescriptName(),
                                            CodeBlock.of("%S", discriminator)
                                        )
                                    }
                                }.build().let {
                                    typescriptFileBuilder.addEnum(it)
                                }
                                val baseTypeName = declaration.getTypescriptName() + "Base"

                                val discriminatorKey =
                                    declaration.getDiscriminatorKeyForSealedClass()

                                InterfaceSpec.builder(baseTypeName).apply {
                                    val typeVariable =
                                        TypeName.typeVariable(
                                            "T",
                                            TypeName.bound(typeEnumTypeName)
                                        )
                                    addTypeVariable(typeVariable)
                                    addProperty(
                                        PropertySpec.builder(
                                            discriminatorKey,
                                            typeVariable,
                                        ).build()
                                    )
                                }.build().let {
                                    typescriptFileBuilder.addInterface(it)
                                }

                                val sealedTypeUnion = TypeAliasSpec.builder(
                                    declaration.getTypescriptName(),
                                    TypeName.unionType(*subclasses.map { TypeName.implicit(it.getTypescriptNameWithNamespace()) }
                                        .toList().toTypedArray())
                                ).addModifiers(Modifier.EXPORT)
                                    .addTSDoc(
                                        "Sealed class generated from {@link %N}\n",
                                        declaration.qualifiedName!!.asString()
                                    ).build()
                                typescriptFileBuilder.addTypeAlias(sealedTypeUnion)
                            } else {
                                error("Only data classes and sealed classes are supported, found: $declaration")
                            }
                        }

                        ClassKind.ENUM_CLASS -> {
                            declaration.assertSerializable {
                                "Enums must be annotated with @Serializable: $declaration"
                            }
                            val enumSpec = EnumSpec.builder(declaration.getTypescriptName()).apply {
                                addModifiers(Modifier.EXPORT)
                                addTSDoc(
                                    "Enum generated from {@link %N}\n",
                                    declaration.qualifiedName!!.asString()
                                )
                                declaration.declarations.filterIsInstance<KSClassDeclaration>()
                                    .filter { it.classKind == ClassKind.ENUM_ENTRY }
                                    .forEach { enumEntry ->
                                        val name = enumEntry.simpleName.asString()
                                        addConstant(name, CodeBlock.of("%S", name))
                                    }
                            }.build()
                            typescriptFileBuilder.addEnum(enumSpec)
                        }

                        ClassKind.ENUM_ENTRY -> error("Enum entries are not supported")
                        ClassKind.OBJECT -> {
                            declaration.assertSerializable {
                                "Objects must be annotated with @Serializable: $declaration"
                            }
                            val interfaceSpec =
                                InterfaceSpec.builder(declaration.getTypescriptName()).apply {
                                    addModifiers(Modifier.EXPORT)
                                    addTSDoc(
                                        "Object generated from {@link %N}\n",
                                        declaration.qualifiedName!!.asString()
                                    )
                                    if (sealedBaseType != null) {
                                        addSuperInterface(sealedBaseType)
                                    }
                                }.build()
                            typescriptFileBuilder.addInterface(interfaceSpec)
                        }

                        ClassKind.ANNOTATION_CLASS -> error("Annotation classes are not supported")
                    }
                }

                is KSFunctionDeclaration -> {
                    error("Function declarations are not supported")
                }

                is KSTypeAlias -> {
                    val type = declaration.type.resolve()
                    val typeAliasSpec = TypeAliasSpec.builder(
                        declaration.getTypescriptName(),
                        getTypescriptTypeName(type)
                    )
                        .addModifiers(Modifier.EXPORT)
                        .addTSDoc(
                            "Type alias generated from {@link %N}\n",
                            declaration.qualifiedName!!.asString()
                        )
                        .build()

                    typescriptFileBuilder.addTypeAlias(typeAliasSpec)
                }

                is KSPropertyDeclaration -> {
                    error("Property declarations are not supported")
                }

                is KSTypeParameter -> {
                    error("Type parameter declarations are not supported")
                }

                else -> {
                    error("Unsupported declaration: $declaration")
                }
            }
        }
    }

    /**
     * Create js mappings from and to json for a given declaration.
     */
    private fun createTypescriptTypeMapping(
        declaration: KSDeclaration,
        typescriptFileBuilder: ModuleSpec.Builder,
    ) {
        when (declaration.qualifiedName) {
            else -> when (declaration) {
                is KSClassDeclaration -> {
                    val sealedSuperclass = declaration.getSealedSuperclass()

                    when (declaration.classKind) {
                        ClassKind.INTERFACE -> error("Interfaces are not supported")
                        ClassKind.CLASS -> {
                            if (com.google.devtools.ksp.symbol.Modifier.DATA in declaration.modifiers) {
                                // data class
                                val fromJson =
                                    FunctionSpec.builder(declaration.getTypescriptFromJsonFunctionName())
                                        .apply {
                                            val nameAllocator = NameAllocator()

                                            addModifiers(Modifier.EXPORT)
                                            addTSDoc(
                                                "Mapping generated from {@link %N}\n",
                                                declaration.qualifiedName!!.asString()
                                            )
                                            val jsonParameterTag = "json"
                                            nameAllocator.newName("json", jsonParameterTag)
                                            addParameter(
                                                ParameterSpec.builder(
                                                    nameAllocator[jsonParameterTag],
                                                    TypeName.ANY,
                                                ).build()
                                            )
                                            addCode(
                                                CodeBlock.builder().apply {
                                                    addStatement(
                                                        "return {%>%L%<}",
                                                        buildList {
                                                            if (sealedSuperclass != null) {
                                                                val discriminatorKey =
                                                                    sealedSuperclass.getDiscriminatorKeyForSealedClass()
                                                                val typeEnum =
                                                                    declaration.getSealedSubclassTypeEnum(
                                                                        sealedSuperclass
                                                                    )
                                                                add(
                                                                    CodeBlock.of(
                                                                        "%N: %T",
                                                                        discriminatorKey,
                                                                        typeEnum,
                                                                    )
                                                                )
                                                            }
                                                            addAll(
                                                                declaration.getAllProperties().map {
                                                                    val name = it.getJSName()
                                                                    CodeBlock.of(
                                                                        "%N: %L",
                                                                        name,
                                                                        convertJsonToType(
                                                                            CodeBlock.of(
                                                                                "%N[%S]",
                                                                                nameAllocator[jsonParameterTag],
                                                                                name,
                                                                            ),
                                                                            it.type.resolve(),
                                                                            nameAllocator.copy(),
                                                                        )
                                                                    )
                                                                }
                                                            )
                                                        }.joinToCode(
                                                            separator = ",\n",
                                                            prefix = "\n",
                                                            suffix = "\n"
                                                        ),
                                                    )
                                                }.build()
                                            )
                                            returns(getTypescriptTypeName(declaration.asStarProjectedType()))
                                        }.build()

                                val toJson =
                                    FunctionSpec.builder(declaration.getTypescriptToJsonFunctionName())
                                        .apply {
                                            val nameAllocator = NameAllocator()
                                            addModifiers(Modifier.EXPORT)
                                            addTSDoc(
                                                "Mapping generated from {@link %N}\n",
                                                declaration.qualifiedName!!.asString()
                                            )
                                            val valueParameterTag = "value"
                                            nameAllocator.newName("value", valueParameterTag)
                                            addParameter(
                                                ParameterSpec.builder(
                                                    nameAllocator[valueParameterTag],
                                                    getTypescriptTypeName(declaration.asStarProjectedType()),
                                                ).build()
                                            )
                                            addCode(
                                                CodeBlock.builder().apply {
                                                    addStatement(
                                                        "return {%>%L%<}",
                                                        buildList {
                                                            if (sealedSuperclass != null) {
                                                                val discriminatorKey =
                                                                    sealedSuperclass.getDiscriminatorKeyForSealedClass()
                                                                val typeEnum =
                                                                    declaration.getSealedSubclassTypeEnum(
                                                                        sealedSuperclass
                                                                    )
                                                                add(
                                                                    CodeBlock.of(
                                                                        "%N: %T",
                                                                        discriminatorKey,
                                                                        typeEnum,
                                                                    )
                                                                )
                                                            }
                                                            addAll(
                                                                declaration.getAllProperties().map {
                                                                    val name = it.getJSName()
                                                                    CodeBlock.of(
                                                                        "%N: %L",
                                                                        name,
                                                                        convertTypeToJson(
                                                                            CodeBlock.of(
                                                                                "%N[%S]",
                                                                                nameAllocator[valueParameterTag],
                                                                                name,
                                                                            ),
                                                                            it.type.resolve(),
                                                                            nameAllocator.copy(),
                                                                        )
                                                                    )
                                                                }
                                                            )
                                                        }.joinToCode(
                                                            separator = ",\n",
                                                            prefix = "\n",
                                                            suffix = "\n"
                                                        ),
                                                    )
                                                }.build()
                                            )
                                            returns(TypeName.ANY)
                                        }.build()
                                typescriptFileBuilder.addFunction(fromJson)
                                typescriptFileBuilder.addFunction(toJson)
                            } else if (com.google.devtools.ksp.symbol.Modifier.SEALED in declaration.modifiers) {
                                val subclasses = declaration.getSealedSubclasses()
                                val fromJson =
                                    FunctionSpec.builder(declaration.getTypescriptFromJsonFunctionName())
                                        .apply {
                                            addModifiers(Modifier.EXPORT)
                                            addTSDoc(
                                                "Mapping generated from {@link %N}\n",
                                                declaration.qualifiedName!!.asString()
                                            )
                                            val jsonParameterName = "json"
                                            addParameter(
                                                ParameterSpec.builder(
                                                    jsonParameterName,
                                                    TypeName.ANY,
                                                ).build()
                                            )
                                            addCode(
                                                CodeBlock.builder().apply {
                                                    val typeVariableType = "type"
                                                    addStatement(
                                                        "const %N = %N[%S]",
                                                        typeVariableType,
                                                        jsonParameterName,
                                                        declaration.getDiscriminatorKeyForSealedClass()
                                                    )
                                                    addStatement(
                                                        "switch (%N) {%>%L%<}",
                                                        typeVariableType,
                                                        buildList {
                                                            addAll(
                                                                subclasses.map {
                                                                    val typeEnum =
                                                                        it.getSealedSubclassTypeEnum(
                                                                            declaration
                                                                        )
                                                                    CodeBlock.of(
                                                                        "case %T: return %N(%N);",
                                                                        typeEnum,
                                                                        it.getTypescriptFromJsonFunctionNameWithNamespace(),
                                                                        jsonParameterName,
                                                                    )
                                                                }
                                                            )
                                                            add(
                                                                CodeBlock.of(
                                                                    "default: throw new %T(%S + %N);",
                                                                    TypescriptErrorTypeName,
                                                                    "Unknown discriminator value: ",
                                                                    typeVariableType,
                                                                )
                                                            )
                                                        }.joinToCode(
                                                            separator = "\n",
                                                            prefix = "\n",
                                                            suffix = "\n"
                                                        ),
                                                    )
                                                }.build()
                                            )
                                            returns(getTypescriptTypeName(declaration.asStarProjectedType()))
                                        }.build()

                                val toJson =
                                    FunctionSpec.builder(declaration.getTypescriptToJsonFunctionName())
                                        .apply {
                                            addModifiers(Modifier.EXPORT)
                                            addTSDoc(
                                                "Mapping generated from {@link %N}\n",
                                                declaration.qualifiedName!!.asString()
                                            )
                                            val valueParameterName = "value"
                                            addParameter(
                                                ParameterSpec.builder(
                                                    valueParameterName,
                                                    getTypescriptTypeName(declaration.asStarProjectedType()),
                                                ).build()
                                            )
                                            addCode(
                                                CodeBlock.builder().apply {
                                                    val typeVariableType = "type"
                                                    addStatement(
                                                        "const %N = %N[%S]",
                                                        typeVariableType,
                                                        valueParameterName,
                                                        declaration.getDiscriminatorKeyForSealedClass()
                                                    )
                                                    addStatement(
                                                        "switch (%N) {%>%L%<}",
                                                        typeVariableType,
                                                        buildList {
                                                            addAll(
                                                                subclasses.map {
                                                                    val typeEnum =
                                                                        it.getSealedSubclassTypeEnum(
                                                                            declaration
                                                                        )
                                                                    CodeBlock.of(
                                                                        "case %T: return %N(%N);",
                                                                        typeEnum,
                                                                        it.getTypescriptToJsonFunctionNameWithNamespace(),
                                                                        valueParameterName,
                                                                    )
                                                                }
                                                            )
                                                            add(
                                                                CodeBlock.of(
                                                                    "default: throw new %T(%S + %N);",
                                                                    TypescriptErrorTypeName,
                                                                    "Unknown discriminator value: ",
                                                                    typeVariableType,
                                                                )
                                                            )
                                                        }.joinToCode(
                                                            separator = "\n",
                                                            prefix = "\n",
                                                            suffix = "\n"
                                                        ),
                                                    )
                                                }.build()
                                            )
                                            returns(TypeName.ANY)
                                        }.build()
                                typescriptFileBuilder.addFunction(fromJson)
                                typescriptFileBuilder.addFunction(toJson)
                            } else {
                                error("Only data classes and sealed classes are supported, found: $declaration")
                            }
                        }

                        ClassKind.ENUM_CLASS -> {
                            val fromJson =
                                FunctionSpec.builder(declaration.getTypescriptFromJsonFunctionName())
                                    .apply {
                                        addModifiers(Modifier.EXPORT)
                                        addTSDoc(
                                            "Mapping generated from {@link %N}\n",
                                            declaration.qualifiedName!!.asString()
                                        )
                                        val jsonParameterName = "json"
                                        addParameter(
                                            ParameterSpec.builder(
                                                jsonParameterName,
                                                TypeName.ANY,
                                            ).build()
                                        )
                                        addCode(
                                            CodeBlock.builder().apply {
                                                addStatement(
                                                    "return %N",
                                                    jsonParameterName,
                                                )
                                            }.build()
                                        )
                                        returns(getTypescriptTypeName(declaration.asStarProjectedType()))
                                    }.build()

                            val toJson =
                                FunctionSpec.builder(declaration.getTypescriptToJsonFunctionName())
                                    .apply {
                                        addModifiers(Modifier.EXPORT)
                                        addTSDoc(
                                            "Mapping generated from {@link %N}\n",
                                            declaration.qualifiedName!!.asString()
                                        )
                                        val valueParameterName = "value"
                                        addParameter(
                                            ParameterSpec.builder(
                                                valueParameterName,
                                                getTypescriptTypeName(declaration.asStarProjectedType()),
                                            ).build()
                                        )
                                        addCode(
                                            CodeBlock.builder().apply {
                                                addStatement(
                                                    "return %N",
                                                    valueParameterName
                                                )
                                            }.build()
                                        )
                                        returns(TypeName.ANY)
                                    }.build()
                            typescriptFileBuilder.addFunction(fromJson)
                            typescriptFileBuilder.addFunction(toJson)
                        }

                        ClassKind.ENUM_ENTRY -> error("Enum entries are not supported")
                        ClassKind.OBJECT -> {
                            val fromJson =
                                FunctionSpec.builder(declaration.getTypescriptFromJsonFunctionName())
                                    .apply {
                                        addModifiers(Modifier.EXPORT)
                                        addTSDoc(
                                            "Mapping generated from {@link %N}\n",
                                            declaration.qualifiedName!!.asString()
                                        )
                                        val jsonParameterName = "json"
                                        addParameter(
                                            ParameterSpec.builder(
                                                jsonParameterName,
                                                TypeName.ANY,
                                            ).build()
                                        )
                                        addCode(
                                            CodeBlock.builder().apply {
                                                addStatement(
                                                    "return %N",
                                                    jsonParameterName,
                                                )
                                            }.build()
                                        )
                                        returns(getTypescriptTypeName(declaration.asStarProjectedType()))
                                    }.build()

                            val toJson =
                                FunctionSpec.builder(declaration.getTypescriptToJsonFunctionName())
                                    .apply {
                                        addModifiers(Modifier.EXPORT)
                                        addTSDoc(
                                            "Mapping generated from {@link %N}\n",
                                            declaration.qualifiedName!!.asString()
                                        )
                                        val valueParameterName = "value"
                                        addParameter(
                                            ParameterSpec.builder(
                                                valueParameterName,
                                                getTypescriptTypeName(declaration.asStarProjectedType()),
                                            ).build()
                                        )
                                        addCode(
                                            CodeBlock.builder().apply {
                                                addStatement(
                                                    "return %N",
                                                    valueParameterName
                                                )
                                            }.build()
                                        )
                                        returns(TypeName.ANY)
                                    }.build()
                            typescriptFileBuilder.addFunction(fromJson)
                            typescriptFileBuilder.addFunction(toJson)
                        }

                        ClassKind.ANNOTATION_CLASS -> error("Annotation classes are not supported")
                    }
                }

                is KSFunctionDeclaration -> {
                    error("Function declarations are not supported")
                }

                is KSTypeAlias -> {
                    val type = declaration.type.resolve()

                    val fromJson =
                        FunctionSpec.builder(declaration.getTypescriptFromJsonFunctionName())
                            .apply {
                                val nameAllocator = NameAllocator()
                                addModifiers(Modifier.EXPORT)
                                addTSDoc(
                                    "Mapping generated from {@link %N}\n",
                                    declaration.qualifiedName!!.asString()
                                )
                                val jsonParameterTag = UUID.randomUUID()
                                nameAllocator.newName("json", jsonParameterTag)

                                addParameter(
                                    ParameterSpec.builder(
                                        nameAllocator[jsonParameterTag],
                                        TypeName.ANY,
                                    ).build()
                                )
                                addCode(
                                    CodeBlock.of(
                                        "return %L", convertJsonToType(
                                            CodeBlock.of(
                                                "%N",
                                                nameAllocator[jsonParameterTag]
                                            ),
                                            type,
                                            nameAllocator.copy(),
                                        )
                                    )
                                )
                                returns(getTypescriptTypeName(type))
                            }.build()

                    val toJson =
                        FunctionSpec.builder(declaration.getTypescriptToJsonFunctionName())
                            .apply {
                                val nameAllocator = NameAllocator()
                                addModifiers(Modifier.EXPORT)
                                addTSDoc(
                                    "Mapping generated from {@link %N}\n",
                                    declaration.qualifiedName!!.asString()
                                )
                                val valueParameterTag = UUID.randomUUID()
                                nameAllocator.newName("value", valueParameterTag)
                                addParameter(
                                    ParameterSpec.builder(
                                        nameAllocator[valueParameterTag],
                                        getTypescriptTypeName(type),
                                    ).build()
                                )
                                addCode(
                                    CodeBlock.of(
                                        "return %L",
                                        convertTypeToJson(
                                            CodeBlock.of(
                                                "%N",
                                                nameAllocator[valueParameterTag],
                                            ),
                                            type,
                                            nameAllocator.copy(),
                                        )
                                    )
                                )
                                returns(TypeName.ANY)
                            }.build()
                    typescriptFileBuilder.addFunction(fromJson)
                    typescriptFileBuilder.addFunction(toJson)
                }

                is KSPropertyDeclaration -> {
                    error("Property declarations are not supported")
                }

                is KSTypeParameter -> {
                    error("Type parameter declarations are not supported")
                }

                else -> {
                    error("Unsupported declaration: $declaration")
                }
            }
        }
    }

    @OptIn(ExperimentalSerializationApi::class)
    private fun KSDeclaration.getDiscriminatorKeyForSealedClass(): String {
        val defaultDiscriminatorKey = "type"
        return getJsonClassDiscriminatorAnnotationOrNull()?.discriminator
            ?: defaultDiscriminatorKey
    }

    private fun needsSerialization(ksType: KSType): Boolean {
        val useJsonSerialization = true
        return ksType.declaration.qualifiedName?.asString() !in setOf(
            "kotlin.Any",
            "kotlin.Boolean",
            "kotlin.Byte",
            "kotlin.Char",
            "kotlin.Double",
            "kotlin.Float",
            "kotlin.Int",
            "kotlin.Long",
            "kotlin.Number",
            "kotlin.Short",
            "kotlin.String",
            "kotlin.Unit",
        ) && (useJsonSerialization || ksType.declaration.qualifiedName?.asString() !in setOf(
            "kotlin.Array",
            "kotlin.collections.List",
            "kotlin.collections.Set",
            "kotlin.collections.Map",
        ))
    }

    private fun KSPropertyDeclaration.getJSName(): String {
        return getSerialNameAnnotationOrNull()?.value ?: simpleName.asString()
    }

    private fun KSClassDeclaration.getSealedSubclassDiscriminatorValue() =
        (getSerialNameAnnotationOrNull()?.value
            ?: error("Sealed subclasses must be annotated with @SerialName: ${this}"))

    private fun toTypescriptPropertySpec(propertyDeclaration: KSPropertyDeclaration): PropertySpec {
        return PropertySpec.builder(
            propertyDeclaration.getJSName(),
            typeReferenceToTypescriptTypeName(propertyDeclaration.type)
        ).build()
    }

    private fun typeReferenceToTypescriptTypeName(typeReference: KSTypeReference): TypeName {
        val resolvedType = typeReference.resolve()
        return getTypescriptTypeName(resolvedType)
    }

    // Breath-first search to find all used types(property types, sealed types, etc), given initial types
    private fun findAllUsedTypes(types: List<KSType>): Set<KSDeclaration> {
        val toBeProcessed = types.toMutableList()
        val processed = mutableSetOf<KSDeclaration>()

        fun scheduleForProcessing(type: KSType) {
            toBeProcessed.add(type)
        }

        while (toBeProcessed.isNotEmpty()) {
            val current = toBeProcessed.removeAt(0)
            if (current.isError) {
                continue
            }
            val declaration = current.declaration
            if (declaration !in processed) {
                processed.add(declaration)

                when (declaration) {
                    is KSClassDeclaration -> {

                        when (declaration.classKind) {
                            ClassKind.CLASS -> {
                                if (com.google.devtools.ksp.symbol.Modifier.DATA in declaration.modifiers) {
                                    // data class
                                    declaration.getAllProperties().forEach {
                                        scheduleForProcessing(it.type.resolve())
                                    }
                                } else if (com.google.devtools.ksp.symbol.Modifier.SEALED in declaration.modifiers) {
                                    // sealed class
                                    declaration.getSealedSubclasses().forEach {
                                        scheduleForProcessing(it.asStarProjectedType())
                                    }
                                }
                            }

                            else -> Unit
                        }
                        declaration.superTypes.forEach {
                            scheduleForProcessing(it.resolve())
                        }
                    }

                    is KSTypeAlias -> {
                        scheduleForProcessing(declaration.type.resolve())
                    }

                    is KSFunctionDeclaration -> {
                        error("Function declarations are not supported")
                    }

                    is KSPropertyDeclaration -> {
                        scheduleForProcessing(declaration.type.resolve())
                    }

                    is KSTypeParameter -> {
                        declaration.bounds.map { it.resolve() }.forEach(::scheduleForProcessing)
                    }

                    else -> {
                        error("Unsupported declaration: $declaration")
                    }
                }
            }
            current.arguments.forEach {
                val type = it.type
                // if not a type variable
                if (type != null) {
                    scheduleForProcessing(type.resolve())
                }
            }
        }
        return processed
    }

    private fun filterTypesForGeneration(types: Set<KSDeclaration>): Collection<KSDeclaration> {
        val customTypes = types.filter {
            val defaultTypes = setOf(
                "kotlin.Any",
                "kotlin.Boolean",
                "kotlin.Byte",
                "kotlin.Char",
                "kotlin.Double",
                "kotlin.Float",
                "kotlin.Int",
                "kotlin.Long",
                "kotlin.Number",
                "kotlin.Short",
                "kotlin.String",
                "kotlin.Unit",
                "kotlin.collections.List",
                "kotlin.collections.Map",
                "kotlin.collections.Set",
                "kotlin.time.Duration",
                "kotlinx.datetime.Instant",
                "kotlinx.datetime.LocalDate",
                "kotlinx.datetime.LocalDateTime",
                "kotlinx.datetime.LocalTime",
            )
            it.qualifiedName?.asString() !in defaultTypes
        }

        return customTypes.filter {
            when (it) {
                is KSClassDeclaration -> it.classKind != ClassKind.INTERFACE && it.origin == Origin.KOTLIN
                is KSTypeParameter -> false
                else -> true
            }
        }
    }

    private data class NamespaceNode(
        val name: String,
        val children: List<NamespaceNode>,
        val declarations: List<KSDeclaration>,
    )

    private fun buildNamespaceTree(
        currentNamespace: String,
        declarations: Collection<KSDeclaration>
    ): NamespaceNode {
        val (children, declarationsInNamespace) = declarations.partition {
            it.qualifiedName?.asString()?.removePrefix("$currentNamespace.")?.contains('.') ?: false
        }

        return NamespaceNode(
            name = currentNamespace.substringAfterLast('.'),
            children = children.groupBy {
                it.qualifiedName?.asString()?.removePrefix("$currentNamespace.")
                    ?.substringBefore('.')
                    ?: error("Expected a qualified name for $it")
            }.map { (name, declarations) ->
                buildNamespaceTree("$currentNamespace.$name".removePrefix("."), declarations)
            },
            declarations = declarationsInNamespace,
        )
    }

    private fun kspDependencies(
        aggregating: Boolean,
        originatingKSFiles: Iterable<KSFile>,
    ): Dependencies = Dependencies(aggregating, *originatingKSFiles.toList().toTypedArray())

    private fun FileSpec.writeTo(
        codeGenerator: CodeGenerator,
        dependencies: Dependencies,
    ) {
        val file = codeGenerator.createNewFileByPath(dependencies, modulePath, extensionName = "ts")
        // Don't use writeTo(file) because that tries to handle directories under the hood
        OutputStreamWriter(file, StandardCharsets.UTF_8)
            .use(::writeTo)
    }

    private fun KSClassDeclaration.isSealedClassSubclass() =
        this.superTypes.any { com.google.devtools.ksp.symbol.Modifier.SEALED in it.resolve().declaration.modifiers }

    private fun KSClassDeclaration.getSealedSuperclass(): KSDeclaration? {
        return if (isSealedClassSubclass()) {
            superTypes.map { it.resolve().declaration }
                .single { com.google.devtools.ksp.symbol.Modifier.SEALED in it.modifiers }
        } else null
    }

    private fun KSClassDeclaration.getSealedSubclassTypeEnum(sealedClassDeclaration: KSDeclaration): TypeName {
        val typeEnumName = sealedClassDeclaration.getTypescriptNameWithNamespace() + "Type"
        val typeEnumTypeName = TypeName.implicit(typeEnumName)
        return typeEnumTypeName.nested(getTypescriptName())
    }

    private fun KSClassDeclaration.getSealedTypescriptBaseType(): TypeName? {
        val sealedClassDeclaration = getSealedSuperclass()
        return if (sealedClassDeclaration != null) {
            val baseTypeName =
                sealedClassDeclaration.getTypescriptNameWithNamespace() + "Base"
            val baseTypeTypeName = TypeName.implicit(baseTypeName)
            baseTypeTypeName.parameterized(getSealedSubclassTypeEnum(sealedClassDeclaration))
        } else null
    }

    private fun CodeBlock.ifNotNull(
        isNullable: Boolean,
        nameAllocator: NameAllocator,
        codeBlock: (nonNullVariableName: String, nameAllocator: NameAllocator) -> CodeBlock
    ): CodeBlock {
        val tempVariableTag = UUID.randomUUID()
        nameAllocator.newName("temp", tempVariableTag)
        return if (isNullable) {
            CodeBlock.of(
                "(() => {%>\nconst %N = %L;\nreturn %N === null ? null : (%L);%<\n})()",
                nameAllocator[tempVariableTag],
                this,
                nameAllocator[tempVariableTag],
                codeBlock(nameAllocator[tempVariableTag], nameAllocator.copy()),
            )
        } else {
            CodeBlock.of(
                "(() => {%>\nconst %N = %L;\nreturn %L;%<\n})()",
                nameAllocator[tempVariableTag],
                this,
                codeBlock(nameAllocator[tempVariableTag], nameAllocator.copy()),
            )
        }
    }

    private fun getDefaultInstantJSType() = options["reakt.native.toolkit.defaultInstantJsType"] ?: "string"

    private fun TypeName.withNullable(nullable: Boolean): TypeName {
        return if (nullable) {
            asNullable()
        } else {
            this
        }
    }

    private fun TypeName.asNullable() = TypeName.unionType(this, TypeName.NULL)

    private val TypescriptErrorTypeName = TypeName.implicit("Error")
    private val TypescriptJsonTypeName = TypeName.implicit("JSON")
    private val TypescriptObjectTypeName = TypeName.implicit("Object")
    private val TypescriptRecordTypeName = TypeName.implicit("Record")
    private val TypescriptDateTypeName = TypeName.implicit("Date")

    private fun recordType(key: TypeName, value: TypeName): TypeName {
        return TypeName.parameterizedType(TypescriptRecordTypeName, key, value)
    }

    private val NextTypeName = TypeName.namedImport("Next", "reakt-native-toolkit")
    private val Next1TypeName = TypeName.namedImport("Next1", "reakt-native-toolkit")
    private val Next2TypeName = TypeName.namedImport("Next2", "reakt-native-toolkit")
    private val NextXTypeName = TypeName.namedImport("NextX", "reakt-native-toolkit")
}
